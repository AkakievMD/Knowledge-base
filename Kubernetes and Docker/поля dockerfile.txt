Короткое описание - FROM — задаёт родительский (главный) образ; LABEL — добавляет метаданные для образа. Хорошее место для размещения информации об авторе;
ENV — создаёт переменную окружения; RUN — запускает команды, создаёт слой образа. Используется для установки пакетов и библиотек внутри контейнера;
COPY  — копирует файлы и директории в контейнер; ADD  — делает всё то же, что и инструкция COPY. Но ещё может распаковывать локальные .tar файлы;
CMD — указывает команду и аргументы для выполнения внутри контейнера. Параметры могут быть переопределены. Использоваться может только одна инструкция CMD;
WORKDIR — устанавливает рабочую директорию для инструкции CMD и ENTRYPOINT; ARG — определяет переменную для передачи Docker’у во время сборки;
ENTRYPOINT — предоставляет команды и аргументы для выполняющегося контейнера. Параметры не могут быть переопределены. EXPOSE — открывает порт;
VOLUME — создаёт точку подключения директории для добавления и хранения постоянных данных. 
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
RUN - будет выполнять любые команды в новом слое поверх текущего изображения и фиксации результатов. Полученное зафиксированное изображение будет использовано на следующем шаге. 
То есть - это поле нужно для запуска команд и создания слоя в контейнере и установки необходимых пакетов в контейнер. Можно уменьшить кол-во слоев перенося команды таким образом.
RUN apt-get update && apt-get install -y \  (RUN apt-get update && apt-get install -yгарантирует, что ваш Dockerfile установит последние версии пакетов без ручного вмешательства)
    aufs-tools \                            ( RUN ["/bin/bash", "-c", "set -o pipefail && wget -O - https://some.site | wc -l > /number"] ) пример смены оболочки
    automake \


CMD и ENTRYPOINT - Требуется определить хотя бы одну инструкцию ENTRYPOINT или CMD для запуска. Если вы не определите ни одной из них, то получите сообщение об ошибке. 
Разница - RUN фактически запускает команду и фиксирует результат; CMD и не выполняет ничего во время сборки, но указывает команду, предназначенную для образа.
Это команда-аргумент запускаемая в контейнере и имеющая следующий вид - CMD и ENTRYPOINT ["executable", "param1", "param2"] Режим exec является рекомендуемым - это предпочтительная форма
Есть проблема запуска НЕ в режиме оболочки и она в том, что мы не можем воспользоваться преимуществами переменных среды (как $PATH) и прочими возможностями, которые предоставляет оболочка
Поскольку мы не можем воспользоваться переменной среды $PATH нужно указать точное путь к исполняемому файлу - это частая операция типа - CMD ["/bin/ping","localhost"] 
Вторая проблема: символы подстановки интерпретируются самой оболочкой, поэтому строка *.jar не будет корректно обработана. 
CMD и ENTRYPOINT - CMD ls /usr или другая команда - можно и с оболочкой если уверены что отработает корректно, ибо иногда бывают недоразумения  
Режим exec рекомендуемый: Это из-за того что контейнеры задуманы так чтобы содержать один процесс. отправленные cигналы внутри перенаправляются процессу в контейере с идентификатором PID1 
Чтобы проверить это можно запустить контейнер ping и попытаться нажать ctrl + c для остановки контейнера. Контейнер, определенный с помощью режима exec, успешно завершает работу.
При использовании режима "shell" контейнер работает не так и оболочка не завершит работу
При использовании exec команда работает с идентификатором процесса PID, равным 1, а процесс sh -c отсутствует. Имейте в виду, что работает так же, если использовать CMD вместо ENTRYPOINT.
И для CMD, и для ENTRYPOINT существуют режимы shell и exec. Если во время выполнения определена только одна из инструкций, то и CMD и ENTRYPOINT будут иметь одинаковый эффект. 
Если вы используете режим shell для ENTRYPOINT, ниже определенная CMD игнорируется, но если использовать режим exec для ENTRYPOINT - аргументы определенные ниже в CMD добавляются в конце
Пример с exec выглядит так - ENTRYPOINT ["ls", "/usr"] а ниже без указания команды указываем поле CMD ["/var"] и можно увидеть вывод содержимого в двух папках. Или подругому...
ENTRYPOINT ["ping"] а ниже CMD ["www.google.com"] сначала утилита потом аргумент
При использовании режима exec для инструкции ENTRYPOINT необходимо использовать режим exec и для инструкции CMD. 
Если этого не сделать, Docker попытается добавить sh -c в уже добавленные аргументы, что может привести к некоторым непредсказуемым результатам.
docker run test [command 1] [arg1] [arg2] - это для CMD чтобы параметры могли быть переопределены.

FROM - Docker-файл должен начинаться с инструкции FROM или ARG, за которой следует FROM. Команда FROM говорит Docker’у использовать базовый образ, который соответствует репозиторию и тегу 
Если тег не указан, по умолчанию берётся последняя версия образа. Но лучше всё же указывать тег базового образа. Чтобы создать докер-файл с нуля нужно для начала в поле FROM указать 
образ той ОС в среде которой это приложение будет работать - это может быть ubuntu, centos и т.д. так как каждый образ содержит в себе некий слепок окружения той среды в которой приложение
будет работать. И после команды запуска этот образ запускается и разворачивается как экземпляр приложения в контейнере
Когда Docker-файл используется для создания локального Docker-образа впервые, он загружает слои, указанные в образе 
Данную команду можно назвать одной из самых необходимых при создании Докерфайла. Она определяет базовый образ для начала процесса построения контейнера. 
Это может быть любой образ, в том числе и созданные вами до этого. Если указанный вами образ не найден на хосте, Докер попытается найти и скачать его. 

LABEL - Следующая инструкция — LABEL. LABEL добавляет метаданные к образу, предоставляет контактную информацию. Она не замедляет процесс запуска и не занимает много места, наоборот
обеспечивает образ полезной информацией, так что обязательно используйте её

ENV - ENV создаёт переменную окружения, которая становится доступной во время запуска контейнера. ENV удобна для обозначения констант. Если константа используется в нескольких местах 
файла Dockerfile, и вам понадобится изменить её значение позднее, это можно будет сделать в одном месте.
Docker-файл зачастую предоставляет несколько путей решения одной задачи. К примеру, RUN, CMD и ENTRYPOINT служат различным целям и могут использоваться для выполнения команд.

ADD - делает то же самое, что и COPY, но с двумя отличиями. ADD может загружать файлы по URL, а также извлекать локальные TAR-файлы. Но официальныя документация не рекомендует 
использовать ADD так, потому что потому что мы попросту не сможем удалить файлы. А дополнительные файлы увеличивают размер образа. Официальная документация для ясности рекомендует 
использовать, когда это возможно, COPY вместе ADD. Жаль только, что в Docker’е невозможно использовать ADD и COPY в одной команде. 

WORKDIR - Меняет текущую рабочую директорию в контейнере для инструкций: COPY, ADD, RUN и ENTRYPOINT. Несколько замечаний: Предпочтительно задать абсолютный путь с помощью WORKDIR, 
а не перемещаться по файловой системе с помощью команд cd в Docker-файле; WORKDIR автоматически создаёт директорию, если её ещё нет; Можно использовать несколько WORKDIR-инструкций. 
Если используются относительные пути — каждая инструкция поменяет рабочую директорию.

ARG - Определяет переменную для передачи из командной строки в образ. Для ARG можно указать значение по умолчанию: ARG my_var=my_default_value.
В отличие от ENV-переменных, ARG-переменные не доступны для запущенных контейнеров. Однако можно использовать их для установки дефолтных значений для ENV-переменных, 
когда создаем образ. И затем ENV-переменные сохраняются.

EXPOSE - Инструкция EXPOSE показывает, какой порт пробрасывать из контейнера. Docker run с флагом -p для пробрасывания и сопоставления нескольких портов во время запуска. 
Флаг в верхнем регистре -P будет пробрасывать все открытые порты.

COPY - Инструкция COPY . ./app говорит Docker’у, что нужно скопировать файлы и папки из вашей локальной сборки в рабочую директорию образа. Cоздаст все нужные папки, если они отсутствуют
VOLUME - определяет, где контейнер будет хранить постоянные данные и получать к ним доступ.
USER — используется для установки UID или имени пользователя, которое будет использоваться в контейнере.
MAINTAINER — данная команда не является исполняемой, и просто определяет значение поля автора образа. Лучше всего ее указывать сразу после команды FROM.