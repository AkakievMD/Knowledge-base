--- (начало любого playbook)
- name: install (имя Playbook)
  hosts: all (хост на котором будет выполнятся задание)
  become: yes (значит что нужно выполнить от root)
  any_errors_fatal: true (любая ошибка в любом задании отменит работу всего playbook на всех хостах, указывается по желанию)

  vars: (под ним создаем переменные со значениями)
    source_file: ./hallo.txt (имя пременной и ее значение)
    destin_file: /root/ansible/hi.txt 
    secret: 30968350640690  
    
  tasks: (ниже создаем параметры задания)
  - name: install packs (имя задания)
    autoclean: yes (Удаляет ненужные пакеты из кеша)
    autoremove: yes (Удаляет зависимости, которые больше не нужны)
    update_cache: yes (работает как apt-update)
    vars: (ниже перечисляем пакеты которые планируем установить ввиде списка переменных, этот способ подходит если нужно сделать много установок не создавая для каждой программы задачу) 
     packages:(создаем переменную и перечисляем пакеты и программы)но можно и через цикл-> - name: install with cycle (имя задания)
       - wget                                                                                apt: name={{ item }} state=latest (пакетный менедер, имена пакетов в цикле и статус состояния)
       - mc                                                                                  loop: (ниже перечисляем имена пакетов для установки через этот цикл)         
       - neofetch                                                                             - httpd 
       - curl                                                                                 - httpd-devel                  
       - git                                                                                  - wget           
    apt: name='{{ packages }}' state=latest (пакетный менедер, имя того что устанавливаем и статус версии) (если в названии пакета указать "*" то сделает апгрейд всех пакетов)
    when: ansible_os_family == "Debian" and/or ansible_distribution_version == "20.04" (пример того как можно использовать условия в задании с любым из логических операторов) 
             
  - shell: touch /root/red.txt (пример того как запускать команды на удаленном хосте) 
  - shell: uptime (если хочешь посмотреть результат команды на контроллере то его можно сохранить в переменную)  
    register: result (модуль сохранения вывода, создаем переменную в которую запишем вывод)
    failed_when: result.rc == 0 или "'World' in result.stdout"(совпадение в условии отменит работу всего playbook на хосте, указывается по желанию, при обычных ошибках также остановится)

  - debug: (ниже указываем переменную из которой считаем результат команды на удаленном хосте)
      var: result (переменная из модуля register) (но также можно сделать вывод значения и обычной переменной)

  - name: commands (имя задания) (пример того как можно в одном задании через цикл выполнить ряд команд на удаленном хосте и при этом не создавать для каждой команды отдельное задание)
    shell: "{{item}}" (модуль команд, внутри переменной item хранится список команд которые перечислены в цикле) (тоже самое можно сделать и с модулем command)
    loop: (модуль цикла, ниже перечисляем команды которые хотим выполнить на удаленном хосте)
      - touch /root/ansible/boom.txt && mkdir /root/ansible/boome (модуль shell использует оболочку /bin/sh и может выполнять команды с этими знаками "< > | ; &" как в этой строке)
      - mv /root/ansible/boom.txt /root/ansible/boome (модуль command работает как и shell но не может использовать оболочку и эти знаки "< > | ; &" и выполняет команды как в этой строке)
      
  - name: install web (имя задания, разовая установка)
    yum: name=nginx state=latest (пакетный менедер, имя того что устанавливаем и статус версии) (если в названии пакета указать "*" то сделает апгрейд всех пакетов)
    security: yes (Если задано значение yes, state=latestто устанавливает только обновления, помеченные как связанные с безопасностью)
    update_cache: yes (Заставьте yum проверять не устарел ли кеш и при необходимости обновить. Имеет эффект только в том случае, если состояние present или является latest)
    download_only: yes (только скачает, не установит их)
    autoremove: yes (Удаляет зависимости, которые больше не нужны, советуют использовать как отдельное задание)
    exclude: kernel*,foo* (указываем пакеты которые не хотим апгрейдить, когда состояние = present или latest)
    update_only: yes (обновляет только установленные пакеты. Не устанавливает пакеты, Действует только в том случае, если состояние является latest)
    when: ansible_os_family == "RedHat" and ansible_distribution_version == "7.9" (пример того как можно использовать условия в задании с любым из логических операторов)

  - name: Coping Myhome (имя задания)
    copy: src={{ source_file }} dest={{ destin_file }} mode=0777 owner=angelo group=angelo (модуль копирования, переменные из которых берем и куда отправляем, владелец и права для файла)
    notify: Restart web (напоминание что нужно сделать рестарт службы в этой точке, отсюда его и вызываем)
    
    copy: src=/root/{{item}} dest=/root/ansible/{{item}} mode=0777 owner=angelo group=angelo(копирование указанных файлов из папки в папку) ( {{item}} - это то, что берем из цикла)
    loop:  (в этом цикле указываем файлы которые собираемся копировать)  (если в src и dest укажем только пути папок без item и цикла то копирует всю папку в другую папку)
     - ter
     - tex
     - tez

  - file: path=/root/ansible/retyty state=directory (модуль создания папки по указанному пути и статус того что создаем)(можно создавать папки через цикл с указанием {{item}} в конце пути) 
    delegate_to: angeloT2 (альтернатива для назначения задания на хост по имени, создавать папку по пути лучше модулем file. И через shell создаст, но выдаст ошибку exist, если делегируем)

  - debug: (ниже можно указать ввиде сообщения с переменной) (иной пример)
      msg: "Secretnoe {{ secret }}" (вывод в виде сообщения)

  - name: start web (имя задания)
    service: name=nginx state=started enabled=yes (модуль сервиса, имя сервиса, ожидаемое состояние и состояние в которое нужно привести)
   
  handlers: (для перезапуска служб, сам по себе не сработает, его нужно вызвать в указанной точке в playbook) (но рестарт можно сделать и через обычное задание в service state=restarted)
  - name: Restart web (имя задания)
    service: name=nginx state=restarted (модуль сервиса, имя сервиса, ожидаемое состояние)