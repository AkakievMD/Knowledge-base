--- (начало любого playbook)
- name: install (имя Playbook)
  hosts: all (хост на котором будет выполнятся задание)
  become: yes (значит что нужно выполнить от root)
  any_errors_fatal: true (любая ошибка в любом задании отменит работу всего playbook на всех хостах, указывается по желанию)

  vars: (под ним создаем переменные со значениями, которые будут глобальными в пределах playbook)
    source_file: ./hallo.txt (имя пременной и ее значение)
    destin_file: /root/ansible/hi.txt 
    secret: 30968350640690  
    
  tasks: (ниже создаем параметры задания)
  - name: install packs (имя задания)
    apt: name='{{ packages }}' state=latest(пакетный менедер, имя программы и статус версии)(если указать "*" в name то сделает апгрейд всех пакетов)(state=absent чтобы удалить)
     autoclean: yes (Удаляет ненужные пакеты из кеша)
     autoremove: yes (Удаляет зависимости, которые больше не нужны)
     update_cache: yes (работает как apt-update)
    vars: (ниже перечисляем пакеты которые планируем установить ввиде списка переменных, этот способ подходит если нужно сделать много установок не создавая для каждой программы задачу) 
     packages:(создаем переменную и перечисляем пакеты и программы)но можно и через цикл-> - name: install with cycle (имя задания)
       - wget                                                                                apt: name={{ item }} state=latest(пакетный менедер, имена пакетов в цикле и статус состояния)
       - mc                                                                                  loop: (ниже перечисляем имена пакетов для установки через этот цикл)         
       - neofetch                                                                             - httpd 
       - curl                                                                                 - httpd-devel                  
       - git                                                                                  - wget           
    when: ansible_os_family == "Debian" and/or ansible_distribution_version == "20.04" (пример того как можно использовать условия в задании с любым из логических операторов)          

  - shell: touch /root/red.txt (пример того как запускать команды на удаленном хосте) 
  - shell: uptime (если хочешь посмотреть результат команды на контроллере то его можно сохранить в переменную)  
    register: result (модуль сохранения вывода, создаем переменную в которую запишем вывод)
    failed_when: result.rc == 0 или "'World' in result.stdout"(совпадение в условии отменит работу всего playbook на хосте, указывается по желанию, при обычных ошибках также остановится)

  - debug: (модуль вывода содержания переменой в консоль) (ниже указываем переменную из которой считаем результат команды на удаленном хосте) 
      var: result (переменная из модуля register) (но также можно сделать вывод значения и обычной переменной)

  - name: commands (имя задания) (пример того как можно в одном задании через цикл выполнить ряд команд на удаленном хосте и при этом не создавать для каждой команды отдельное задание)
    shell: "{{item}}" (модуль команд, внутри переменной item хранится список команд которые перечислены в цикле) (тоже самое можно сделать и с модулем command)
    args: (ниже указываем модуль смены оболочки) (/bin/sh не обрабатывает перенаправление и подстановочные знаки вместе, как показано в скобках ---> (cat < /tmp/*txt), а bash может)
      executable: /bin/bash (этот модуль изменит оболочку, используемую для выполнения команды. Должен быть абсолютный путь к исполняемому файлу)
    loop: (модуль цикла, ниже перечисляем команды которые хотим выполнить на удаленном хосте)
      - touch /root/ansible/boom.txt && mkdir /root/ansible/boome (модуль shell использует оболочки и может выполнять команды с этими знаками "< > | ; &" как в этой строке)
      - mv /root/ansible/boom.txt /root/ansible/boome(модуль command работает как и shell но не может использовать оболочки и эти знаки "< > | ; &" и выполняет команды как в этой строке)

  - group: (модуль управления группами)
     name: james (имя группы)
     state: present (present - создать, absent - удалить)
     gid: 1200 (id группы)
                                                                                                                 - name: deleting of user (имя задания)
  - name: creating user   (имя задания)                                                                            user:  (модуль управления пользователями)   
    user: (модуль управления пользователями)                                                                         name: james (имя пользователя)
     name: james (имя пользователя)                                                                                  state: absent (указываем что пользователь должен отсутствовать)
     group: james (добавить в указанную группу) (есть идентификатор gid=1000(james) )                                remove: yes (подтверждаем удаление)
     groups: angelo, devops (добавить в указанные группы) (и есть идентификатор groups=1000(james) ) 
     shell: /bin/bash (командная оболочка для пользователя)
     uid: 1104 (id пользователя)
     create_home: yes (создать домашнюю папку)
     home: /home/james/ (путь до домашней папки)
     state: present (указываем что учетная запись должна существовать) 
     append: yes ()
       
  - authorized_key: (модуль добавления публичного ssh ключа пользователю) (смена расположения по желанию)
     user: james (имя пользователя)
     state: present (статус ключа - должен ли ключ с заданными опциями быть или не быть в файле)
     key: "{{ lookup('file', '/root/authorized_keys') }}" (откуда берем ключ с контроллера чтобы добавить на удаленный хост, путь хранения указываем свой)
     path: /home/james/ssh/authorized_keys(меняем расположение ключа чтобы подключиться нужно добавить путь до ключа на хосте в файле /etc/ssh/sshd_config в поле AuthorizedKeysFile)
     manage_dir: False (если меняем расположение ключа то советуют ставить такое значение что бы потом была возможность подключиться по ssh)   

  - name: install web (имя задания, разовая установка)
    yum: name=nginx state=latest (пакетный менедер, имя программы и статус версии) (если указать "*" в name то сделает апгрейд всех пакетов) (state=absent чтобы удалить)
     security: yes (Если задано значение yes, а state=latest, то устанавливает только обновления, помеченные как связанные с безопасностью)
     update_cache: yes (Заставьте yum проверять не устарел ли кеш и при необходимости обновить. Имеет эффект только в том случае, если состояние present или является latest)
     download_only: yes (только скачает, не установит их)
     autoremove: yes (Удаляет зависимости, которые больше не нужны, советуют использовать как отдельное задание)
     exclude: kernel*,foo* (указываем пакеты которые не хотим апгрейдить, когда состояние = present или latest)
     update_only: yes (обновляет только установленные пакеты. Не устанавливает пакеты, Действует только в том случае, если состояние является latest)
    when: ansible_os_family == "RedHat" and ansible_distribution_version == "7.9" (пример того как можно использовать условия в задании с любым из логических операторов)

  - name: Coping Myhome (имя задания)
    copy: src={{ source_file }} dest={{ destin_file }} mode=0777 owner=angelo group=angelo(модуль копирования, переменные из которых берем и куда отправляем, владелец и права для файла)
    notify: Restart web (напоминание что нужно сделать рестарт службы в этой точке, отсюда его и вызываем)
    
    copy: src=/root/{{item}} dest=/root/ansible/{{item}} mode=0777 owner=angelo group=angelo(копирование указанных файлов из папки в папку) ( {{item}} - это то, что берем из цикла)
    loop:  (в этом цикле указываем файлы которые собираемся копировать)  (если в src и dest укажем только пути папок без item и цикла то копирует всю папку в другую папку)
     - ter
     - tex
     - tez

  - file: path=/root/ansible/retyty state=directory(модуль создания папок и файлов и статус того что создаем)(можно создавать папки через цикл с указанием {{item}} в конце пути) 
    delegate_to: angeloT2(альтернатива для назначения задания на хост по имени, создавать папку по пути лучше модулем file. И через shell создаст но выдаст ошибку exist, если делегируем)
  - file: path=/root/ansible state=directory recurse=yes owner=angelo group=angelo (пример как рекурсивно поменять владельца содержимого в папке)

  - debug: (модуль вывода содержания переменой в консоль) (ниже можно указать ввиде сообщения с переменной) (иной пример)
      msg: "Secretnoe {{ secret }}" (вывод в виде сообщения)

  - name: start web (имя задания)
    service: name=nginx state=started enabled=yes (модуль сервиса, имя сервиса, ожидаемое состояние и состояние в которое нужно привести)
   
  handlers:(для перезапуска служб, сам по себе не сработает, его нужно вызвать в указанной точке в playbook)(но рестарт можно сделать и через обычное задание в service state=restarted)
  - name: Restart web (имя задания)
    service: name=nginx state=restarted (модуль сервиса, имя сервиса, ожидаемое состояние)

  - name: Create a ext4 filesystem on /dev/sdb1 and check disk blocks (имя задания) 
    filesystem: (модуль создания файловой системы)(стоит помнить что перед принудительной сменой или созданием файловой системы раздел сначала нужно отмонтировать, иначе будет ошибка)
     fstype: ext4 (Тип создаваемой файловой системы)
     dev: /dev/sdb1 (путь к устройству )
     opts: -cc (Список параметров, передаваемых команде mkfs, то есть - ключи, не обязательное поле)
     force: yes (Если yes, позволяет создавать новую файловую систему на устройствах, на которых уже есть файловая система)

  - name: module of founding (имя задания)
    find: (модуль поиска) (чтобы вывести результат поиска в терминал, который записан в переменную и узнать точное расположение, то используй модуль debug: с указанием ниже переменной)
      paths: /tmp (путь до того места где будем искать)
      age: 2d (возраст того что ищем)
      recurse: yes (делать рекурсивный поиск или нет)
      size: 1m (размер того что ищем)
      patterns: '*.old,*.log.gz' (шаблон поиска)
      use_regex: yes (это поле указывается если в патерне задаем большие регулярные выражения)
      file_type: "{{item}}" (тип того что ищем из указанного в цикле)
      excludes: 'nginx,mysql' (указываем исключения из поиска)
      hidden: yes (если хотим искать и скрытые тоже)
    loop: (если искать что-то одно то цикл можно не создавать и вместо item указать либо то, либо то )
      - directory
      - file
    register: result (переменная в которую записана вся информация о результате работы find)

  - name: Mount up device by label (имя задания) 
    mount: (модуль монтирования)
     path: /srv/disk (Путь к точке монтирования)
     src: /dev/sda4 (путь к разделу который будем монтировать)
     fstype: ext4 (файловая система раздела)
     state: mounted (ожидаемое состояние)
 
  - name: Run a script (имя задания) 
    script: /some/local/script.sh (путь до скрипта, который находится на контроллере ansible, удаленные скрипты лучше запускать через модуль shell: /path/to/remote_script так быстрее)

  - name: install elasticsearch 6.x deb repository (имя задания) 
    apt_repository: (модуль добавления репозитория)
      repo: deb https://artifacts.elastic.co/packages/6.x/apt stable main (указываем репозиторий, версия - стабильная, основная)
      state: present (указаваем что нужно добавить)
      update_cache: yes (работает как apt-update)

  - name: Add repository (имя задания) 
    yum_repository: (модуль добавления репозитория)
     name: epel (имя)
     description: EPEL YUM repo (просто описание)
     baseurl: https://download.fedoraproject.org/pub/epel/$releasever/$basearch/ (URL-адрес каталога, в котором находится каталог repodata репозитория yum, сам репозиторий)
     enabled: yes (Это сообщает yum, использовать ли этот репозиторий)
     file: external_repos (Имя файла без расширения .repo для сохранения репо, не обязательно указывать)
     gpgkey: (URL-адрес, указывающий на защищенный ASCII ключевой файл GPG для репозитория)
     gpgcheck: yes (Сообщает yum, следует ли выполнять проверку подписи GPG для пакетов)

  - template:(модуль копирования шаблонных файлов)(также можно в файле указать переменную из playbook по типу host: "{{host}}" в скобках имя переменной из playbook, а не значение)
      src: /root/ansible/templ.j2 (путь откуда брать файл)(файл должен быть в формате j2, шаблонные переменные могут выглядеть так host: "{{ansible_host}}" эта переменная из инвентаря)
      dest: /root/ansible/templ.txt (точка назначения на удаленном хосте, можно создать новый файл, а можно указать существующий и перезаписать его)
      owner: root (указываем того кто будет владельцем)
      group: root (указываем группу которая будет владельцем)
      mode: 777 (права файла)
      backup: yes (указываем что нужно создать копию файла в той же папке перед его изменением)

  - name: copy a file to ansible-controller (имя задания)
    fetch: (модуль копирования файлов с удаленного хоста на)
     src: /root/ansible/ter.txt (путь откуда брать файл с удаленного хоста, обязательно указываем имя файла)
     dest: /root/ansible/ret.txt (путь куда положить файл на ansible-controller, имя файла не обязательно указывать в конце, но нужно будет добавить параметр flat: yes)
     flat: yes (переопределяет поведение по умолчанию, если dest оканчивается на '/', он будет использовать базовое имя исходного файла, это удобно только если имена файлов уникальны)
     fail_on_missing: yes (указываем, что задача завершится ошибкой, если удаленный файл не может быть прочитан по какой-либо причине)
     validate_checksum: yes (указываем что после получения файлов нужно убедиться, что контрольные суммы источника и назначения совпадают)

  - name: Replace a localhost entry with our own
    lineinfile:
      path: /etc/hosts (путь к файлу в котором нужно заменить указанную в выражении строку, по умолчанию, поле regexp делает замену только в последнем совпадении, если есть и другие)
      regexp: '^127\.0\.0\.1' (если выражение указанно в regexp и дополнительно указанно в insertafter или insertbefore, то учитываться, только если совпадение для regexp не найдено)
      line: 127.0.0.1 localhost maylo
      owner: root (указываем того кто будет владельцем)
      group: root (указываем группу которая будет владельцем)
      mode: '0644' (права файла)
      insertbefore: '^#log' (строка из поля line будет вставлена ​​перед указанной строкой в выражении, если вместо выражения указать это BOF то вставит в начало)
      insertafter: '^#log' (строка из поля line будет вставлена ​​после указанной строки в выражении, если вместо выражения указать это EOF то вставит в конец)
      backup: yes (указываем что нужно создать копию файла в той же папке перед его изменением)
      firstmatch: yes (если необходимо то указываем что нужно заменить первое попавшееся совпадение)
      create: yes (указываем что нужно создать файл и в него добавить указанную строку из поля line, если указанный файл в поле path не существует, используется без полей с выражениями)

  - name: Print the apt package facts (имя задания)
    package_facts: (модуль вывода информации о пакетах)
      manager: apt (типы доступных пакетных менеджеров для проверки rpm, apt, portage, pkg и режим auto)
  - debug:  (модуль вывода содержания переменой в консоль)
      msg: "{{ ansible_facts.packages['wget'] }} are installed!" (указываем переменную и пакет о котором хотим получить информацию)
    when: "'wget' in ansible_facts.packages" (условие что данный пакет должен присутствовать в списке пакетов, который хранится в переменной ansible_facts.packages)