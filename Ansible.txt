--- (начало любого playbook)
- name: install (имя Playbook)
  hosts: all (хост на котором будет выполнятся задание)
  become: yes (значит что нужно выполнить от root)
  any_errors_fatal: true (любая ошибка в любом задании отменит работу всего playbook на всех хостах, указывается по желанию)

  vars: (под ним создаем переменные со значениями, которые будут глобальными в пределах playbook)
    source_file: ./hallo.txt (имя пременной и ее значение)
    destin_file: /root/ansible/hi.txt 
    secret: 30968350640690  
    
  tasks: (ниже создаем параметры задания)
  - name: install packs (имя задания)
    autoclean: yes (Удаляет ненужные пакеты из кеша)
    autoremove: yes (Удаляет зависимости, которые больше не нужны)
    update_cache: yes (работает как apt-update)
    vars: (ниже перечисляем пакеты которые планируем установить ввиде списка переменных, этот способ подходит если нужно сделать много установок не создавая для каждой программы задачу) 
     packages:(создаем переменную и перечисляем пакеты и программы)но можно и через цикл-> - name: install with cycle (имя задания)
       - wget                                                                                apt: name={{ item }} state=latest(пакетный менедер, имена пакетов в цикле и статус состояния)
       - mc                                                                                  loop: (ниже перечисляем имена пакетов для установки через этот цикл)         
       - neofetch                                                                             - httpd 
       - curl                                                                                 - httpd-devel                  
       - git                                                                                  - wget           
    apt: name='{{ packages }}' state=latest(пакетный менедер, имя программы и статус версии)(если указать "*" в name то сделает апгрейд всех пакетов)(state=absent чтобы удалить)
    when: ansible_os_family == "Debian" and/or ansible_distribution_version == "20.04" (пример того как можно использовать условия в задании с любым из логических операторов) 
             
  - shell: touch /root/red.txt (пример того как запускать команды на удаленном хосте) 
  - shell: uptime (если хочешь посмотреть результат команды на контроллере то его можно сохранить в переменную)  
    register: result (модуль сохранения вывода, создаем переменную в которую запишем вывод)
    failed_when: result.rc == 0 или "'World' in result.stdout"(совпадение в условии отменит работу всего playbook на хосте, указывается по желанию, при обычных ошибках также остановится)

  - debug: (ниже указываем переменную из которой считаем результат команды на удаленном хосте)
      var: result (переменная из модуля register) (но также можно сделать вывод значения и обычной переменной)

  - name: commands (имя задания) (пример того как можно в одном задании через цикл выполнить ряд команд на удаленном хосте и при этом не создавать для каждой команды отдельное задание)
    shell: "{{item}}" (модуль команд, внутри переменной item хранится список команд которые перечислены в цикле) (тоже самое можно сделать и с модулем command)
    args: (ниже указываем модуль смены оболочки) (/bin/sh не обрабатывает перенаправление и подстановочные знаки вместе, как показано в скобках ---> (cat < /tmp/*txt), а bash может)
      executable: /bin/bash (этот модуль изменит оболочку, используемую для выполнения команды. Должен быть абсолютный путь к исполняемому файлу)
    loop: (модуль цикла, ниже перечисляем команды которые хотим выполнить на удаленном хосте)
      - touch /root/ansible/boom.txt && mkdir /root/ansible/boome (модуль shell использует оболочки и может выполнять команды с этими знаками "< > | ; &" как в этой строке)
      - mv /root/ansible/boom.txt /root/ansible/boome(модуль command работает как и shell но не может использовать оболочки и эти знаки "< > | ; &" и выполняет команды как в этой строке)

  - group: (модуль управления группами)
     name: james (имя группы)
     state: present (present - создать, absent - удалить)
     gid: 1200 (id группы)
                                                                                                                 - name: deleting of user (имя задания)
  - name: creating user   (имя задания)                                                                            user:  (модуль управления пользователями)   
    user: (модуль управления пользователями)                                                                         name: james (имя пользователя)
     name: james (имя пользователя)                                                                                  state: absent (указываем что пользователь должен отсутствовать)
     group: james (добавить в указанную группу) (есть идентификатор gid=1000(james) )                                remove: yes (подтверждаем удаление)
     groups: angelo, devops (добавить в указанные группы) (и есть идентификатор groups=1000(james) ) 
     shell: /bin/bash (командная оболочка для пользователя)
     uid: 1104 (id пользователя)
     create_home: yes (создать домашнюю папку)
     home: /home/james/ (путь до домашней папки)
     state: present (указываем что учетная запись должна существовать) 
     append: yes ()
       
  - authorized_key: (модуль добавления публичного ssh ключа пользователю) (смена расположения по желанию)
     user: james (имя пользователя)
     state: present (статус ключа - должен ли ключ с заданными опциями быть или не быть в файле)
     key: "{{ lookup('file', '/root/authorized_keys') }}" (откуда берем ключ с контроллера чтобы добавить на удаленный хост, путь хранения указываем свой)
     path: /home/james/ssh/authorized_keys(меняем расположение ключа чтобы подключиться нужно добавить путь до ключа на хосте в файле /etc/ssh/sshd_config в поле AuthorizedKeysFile)
     manage_dir: False (если меняем расположение ключа то советуют ставить такое значение что бы потом была возможность подключиться по ssh)   

  - name: install web (имя задания, разовая установка)
    yum: name=nginx state=latest (пакетный менедер, имя программы и статус версии) (если указать "*" в name то сделает апгрейд всех пакетов) (state=absent чтобы удалить)
    security: yes (Если задано значение yes, а state=latest, то устанавливает только обновления, помеченные как связанные с безопасностью)
    update_cache: yes (Заставьте yum проверять не устарел ли кеш и при необходимости обновить. Имеет эффект только в том случае, если состояние present или является latest)
    download_only: yes (только скачает, не установит их)
    autoremove: yes (Удаляет зависимости, которые больше не нужны, советуют использовать как отдельное задание)
    exclude: kernel*,foo* (указываем пакеты которые не хотим апгрейдить, когда состояние = present или latest)
    update_only: yes (обновляет только установленные пакеты. Не устанавливает пакеты, Действует только в том случае, если состояние является latest)
    when: ansible_os_family == "RedHat" and ansible_distribution_version == "7.9" (пример того как можно использовать условия в задании с любым из логических операторов)

  - name: Coping Myhome (имя задания)
    copy: src={{ source_file }} dest={{ destin_file }} mode=0777 owner=angelo group=angelo(модуль копирования, переменные из которых берем и куда отправляем, владелец и права для файла)
    notify: Restart web (напоминание что нужно сделать рестарт службы в этой точке, отсюда его и вызываем)
    
    copy: src=/root/{{item}} dest=/root/ansible/{{item}} mode=0777 owner=angelo group=angelo(копирование указанных файлов из папки в папку) ( {{item}} - это то, что берем из цикла)
    loop:  (в этом цикле указываем файлы которые собираемся копировать)  (если в src и dest укажем только пути папок без item и цикла то копирует всю папку в другую папку)
     - ter
     - tex
     - tez

  - file: path=/root/ansible/retyty state=directory(модуль создания папок и файлов и статус того что создаем)(можно создавать папки через цикл с указанием {{item}} в конце пути) 
    delegate_to: angeloT2(альтернатива для назначения задания на хост по имени, создавать папку по пути лучше модулем file. И через shell создаст но выдаст ошибку exist, если делегируем)
  - file: path=/root/ansible state=directory recurse=yes owner=angelo group=angelo (пример как рекурсивно поменять владельца содержимого в папке)

  - debug: (ниже можно указать ввиде сообщения с переменной) (иной пример)
      msg: "Secretnoe {{ secret }}" (вывод в виде сообщения)

  - name: start web (имя задания)
    service: name=nginx state=started enabled=yes (модуль сервиса, имя сервиса, ожидаемое состояние и состояние в которое нужно привести)
   
  handlers:(для перезапуска служб, сам по себе не сработает, его нужно вызвать в указанной точке в playbook)(но рестарт можно сделать и через обычное задание в service state=restarted)
  - name: Restart web (имя задания)
    service: name=nginx state=restarted (модуль сервиса, имя сервиса, ожидаемое состояние)