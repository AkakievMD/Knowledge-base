systemctl --failed (покажет упавшие службы) systemctl list-unit-files (покажет список всех демонов и статус коротко) systemctl --all (покажет статус служб развернуто, но только запущеные)
ps ax | grep "nodejs" | wc -l (Считаем количество процессов nodejs) 
ps -ef | awk '{ print $8 }' | sort -n | uniq -c | sort -n | tail -5 (Считаем количество процессов в системе и выводим 5, которые запустили больше всего экземпляров)
id имя пользователя (покажет id групп и т.д.) groups имя пользователя (покажет группу)
journalctl -f (выводит события системы в реальном времени) journalctl -n 10 (выводит указанное кол-во строк последних событий в системе, любое, какое укажешь)
journalctl --since "2021-06-16 17:00:00" --until "2021-06-16 20:00:00" -u sshd.service (покажет все события в указанном диапозоне по выбранному демону) 
journalctl -p 4(по уровню важности)(0 неработоспособность системы,1 нужно вмешаться,2 критическое состояние,3 ошибки,4 предупреждения,5 уведомления,6 информационные sms,7 отладочные sms)
journalctl /usr/sbin/nginx --since today (можно просмотреть лог приложения, указав его исполняемый файл или его PID (journalctl _PID=1) )
yum autoremove имя пакета (удалить пакет и стереть все ненужные зависимости)  yum remove имя пакета (удалить пакет)
yum list | grep имя пакета (Если нужно удалить пакет, но не уверен в его точном имени то можно посмотреть так)   rpm -qa | grep имя пакета (тоже самое только покажет другие пакеты)
mount /dev/sda5/ путь до папки (смонтирует раздел в указанную папку) umount путь до папки, куда смонтирован раздел (отмонтирует раздел в папке)
mv red.txt blue.txt (пример того, как переименовать файл или папку) mv red.txt путь до папки, куда перемещаем файл (пример перемещения)
touch /root/ansible/red.txt (создать файл red.txt по указанному пути)
rm -rf имя папки, в которой будем удалять содержимое (удалит содержимое и папку, без ключа -r чтобы удалить только файлы внутри папки)
file red.txt (выведет информацию о файле) file -s /dev/sda1 (если раздел не смонтирован то этой комндой можно посмотреть тип файловой системы)
df -Th (выведет размер файловой системы, ее разделов и тип файловой системы, что бы понимать сколько свободного места в разделах файловой систем и насколько они заполнены) 
ls *.txt | xargs rm -f(пример работы с xargs. передаем их одной строкой)  ls | grep *.txt | xargs rm -f(пример работы с xargs. передаем их одной строкой)
jobs (выведет все процессы, которые запущены в фоновом режиме)
fg 1 (заходим в фоновый процесс по номеру процесса и выходя останавливаем его)
bg 1 (запускаем процесс обратно работать в фоновом режиме по его номеру)
ps aux (сделает снимок процессов из диспетчера задач выведет его в терминале)
ps -eo user,pid,pcpu,nice,comm (выведет снимок активных процессов по указанным полям, но их может быть больше или меньше)
killall sleep (убьет все процессы с именем, которое укажем)
pgrep sleep -l (отсортирует и выведет процессы по указанному имени процесса)  pgrep -u akakiev -l(отсортирует и выведет все процесы указанного пользователя)
pkill sleep (завершает процесс), pstree (покажет дерево процессов), free (покажет загруженность оперативки)
renice 15 -u akakiev (изменит приоритет всех процессов пользователя)
du -chs ansible red (выведет размер папок по указанному пути. если уже в папке то просто перечисляем папки в папке, если нет, то указываем полные пути с места просмотра /root/ /home/misha)
du -hс --max-depth=2 /root(задает глубину папок для просмотра Если задать глубину равную 2 то можно посмотреть общие размеры всех папок по пути не дальше двух вложений с места просмотра)
fsck -t ext4 /dev/sda1 (проверяет указанную файловую систему в разделе)
dumpe2fs /dev/sda1 > info.txt (выводим информацию о файловой системе в файл)
cp -r /etc/apache/ /backup/ (рекурсивно копирует одну дерикторию в другую) find /home/angelo -name "*.txt" (применяя регулярные выражения оборачивай в ковычки или будет ошибка)
find / -name имя файла или дериктории (будет искать указанный файл или дерикторию там где укажем по имени)
tail -n 10 имя файла (выведет указанное кол-во строк с конца файла) 
grep -n hallo t.txt (Чтобы показать номер строки, где была найдена искомая строка) grep -i -r Hallo /root (ищет слово рекурсивно везде где укажем, с ключом -i независимо от регистра)
grep -r Hallo /root (Чтобы вести поиск среди всех файлов по указанному пути рекурсивно)  grep -e World -e Hallo -e mir -e 'my home' t.txt (ПОИСК ПО НЕСКОЛЬКИМ СЛОВАМ)
ls t* | xargs grep hallo (рекурсивная выборка с ограниченым списком) ls y* | xargs rm -rf && ls t* | xargs rm -rf (пример логического "и" сначала эту команду потом эту)
zgrep/grep --color=always '100' ./app.log_2021-04-13* | grep --color=always 'IT' (если нужно грепнуть другой греп, пример синтаксиса и передачи вывода для второго "grep")
zcat /usr/share/doc/zabbix-server-mysql*/create.sql.gz | mysql -u zabbix_user -p zabbix_db -ppassw0rd123(через ключ -p и пароль слитно выполняем команду с автозаполнением пароля - пример)
top/htop (откроет диспетчер задач, поле load average —  среднее значение загрузки системы за период времени, в виде трёх значений, за последние 1, 5 и 15 минут, чем ниже, тем лучше
