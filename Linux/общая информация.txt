Резидентная память данных
РПД является наиболее гибким адресным пространством, которое позволяет реализовать режимы прямой, регистровой, косвенной и битовой адресации. РПД состоит из таких областей:  1) ОЗУ объемом 128 байтов - адреса 00...7FH (0..127);  2) Блок регистров специальных функций (РСФ) - содержит 20 однобайтовых регистров, размещенных по адресам, кратным 8, в диапазоне 80...FFH (128-255). Другие адреса из этой области недоступные и являются ошибочными. Внутреннее ОЗУ предполагает прямую и косвенную адресацию, а банки рабочих регистров, которые входят в него, - также и регистровую адресацию.

Виртуа́льная па́мять - это адресное пространство выделеное конкретному процессу, то есть, диапозон адресов которыми можно аперировать. Они не обязаны как-то быть выражены физической памятью, например, приложение запросило много памяти, но пока никак не использует, железную память можно пока никак не тратить, если есть необходимость сделать запись, то может быть сопоставлено адресное пространство виртуальной памяти с физическим адресным пространством оперативной памяти комьпютера, в таком случае выделяется резидентная память и в нее сохраняется значение. Это метод управления памятью компьютера позволяющий выполнять программы, требующие больше оперативной памяти, чем имеется в компьютере, путём автоматического перемещения частей программы между основной памятью и вторичным хранилищем (например, жёстким диском). 
Для выполняющейся программы данный метод полностью прозрачен и не требует дополнительных усилий со стороны программиста, однако реализация этого метода требует как аппаратной поддержки, так и поддержки со стороны операционной системы.
В системе с виртуальной памятью используемые программами адреса, называемые виртуальными адресами, транслируются в физические адреса в памяти компьютера. Трансляцию виртуальных адресов в физические выполняет аппаратное обеспечение, называемое блоком управления памятью. Для программы основная память выглядит как доступное и непрерывное адресное пространство либо как набор непрерывных сегментов, вне зависимости от наличия у компьютера соответствующего объёма оперативной памяти. Управление виртуальными адресными пространствами, соотнесение физической и виртуальной памяти, а также перемещение фрагментов памяти между основным и вторичным хранилищами выполняет операционная система (см. подкачка страниц).
Виртуальная память-это представление RAM плюс, возможно, некоторое пространство подкачки, предоставляемое менеджером виртуальной памяти. Современные OSs имеют менеджеры виртуальной памяти и предоставляют виртуальную память процессам, чтобы исполняющая программа могла вести себя так, как если бы у нее было непрерывное адресное пространство, размер которого не ограничен фактическим RAM. Страницы или блоки, составляющие виртуальную память, могут быть сопоставлены в любом месте RAM, так что виртуальные страницы contiguos должны храниться в областях contiguos RAM. Или они могут быть заменены на пространство страницы или пространство подкачки, ожидая там до тех пор, пока это не потребуется, после чего они будут прочитаны OS и сопоставлены с какой-либо страницей RAM. Некоторые или все страницы памяти, принадлежащие процессу, могут быть заменены
Применение виртуальной памяти позволяет:
освободить программиста от необходимости вручную управлять загрузкой частей программы в память и согласовывать использование памяти с другими программами
предоставлять программам больше памяти, чем физически установлено в системе
в многозадачных системах изолировать выполняющиеся программы друг от друга путём назначения им непересекающихся адресных пространств (см. защита памяти)
В настоящее время виртуальная память аппаратно поддерживается в большинстве современных процессоров. В то же время в микроконтроллерах и в системах специального назначения, где либо требуется очень быстрая работа, либо есть ограничения на длительность отклика (системы реального времени), виртуальная память используется относительно редко. Также в таких системах реже встречается многозадачность и сложные иерархии памяти.

Страничная память
В большинстве современных операционных систем виртуальная память организуется с помощью страничной адресации. Оперативная память делится на страницы: области памяти фиксированной длины (например, 4096 байт[13]), которые являются минимальной единицей выделяемой памяти (то есть даже запрос на 1 байт от приложения приведёт к выделению ему страницы памяти). Исполняемый процессором пользовательский поток обращается к памяти с помощью адреса виртуальной памяти, который делится на номер страницы и смещение внутри страницы. Процессор преобразует номер виртуальной страницы в адрес соответствующей ей физической страницы при помощи буфера ассоциативной трансляции (TLB). Если ему не удалось это сделать, то требуется дозаполнение буфера путём обращения к таблице страниц (так называемый Page Walk), что может сделать либо сам процессор, либо операционная система (в зависимости от архитектуры)
Если страница была выгружена из оперативной памяти, то операционная система подкачивает страницу с жёсткого диска в ходе обработки события Page fault (см. свопинг, подкачка страниц). При запросе на выделение памяти операционная система может «сбросить» на жёсткий диск страницы, к которым давно не было обращений. Критические данные (например, код запущенных и работающих программ, код и память ядра системы) обычно находятся в оперативной памяти (исключения существуют, однако они не касаются тех частей, которые отвечают за обработку аппаратных прерываний, работу с таблицей страниц и использование файла подкачки).
Сегментная адресация памяти
Механизм организации виртуальной памяти, при котором виртуальное пространство делится на части произвольного размера — сегменты. Этот механизм позволяет, к примеру, разбить данные процесса на логические блоки.[15] Для каждого сегмента, как и для страницы, могут быть назначены права доступа к нему пользователя и его процессов. При загрузке процесса часть сегментов помещается в оперативную память (при этом для каждого из этих сегментов операционная система подыскивает подходящий участок свободной памяти), а часть сегментов размещается в дисковой памяти. Сегменты одной программы могут занимать в оперативной памяти несмежные участки. Во время загрузки система создает таблицу сегментов процесса (аналогичную таблице страниц), в которой для каждого сегмента указывается начальный физический адрес сегмента в оперативной памяти, размер сегмента, правила доступа, признак модификации, признак обращения к данному сегменту за последний интервал времени и некоторая другая информация. 
Если виртуальные адресные пространства нескольких процессов включают один и тот же сегмент, то в таблицах сегментов этих процессов делаются ссылки на один и тот же участок оперативной памяти, в который данный сегмент загружается в единственном экземпляре. Система с сегментной организацией функционирует аналогично системе со страничной организацией: время от времени происходят прерывания, связанные с отсутствием нужных сегментов в памяти, при необходимости освобождения памяти некоторые сегменты выгружаются, при каждом обращении к оперативной памяти выполняется преобразование виртуального адреса в физический. Кроме того, при обращении к памяти проверяется, разрешен ли доступ требуемого типа к данному сегменту.
Виртуальный адрес при сегментной организации памяти может быть представлен парой (g, s), где g — номер сегмента, а s — смещение в сегменте. Физический адрес получается путём сложения начального физического адреса сегмента, найденного в таблице сегментов по номеру g, и смещения s.
Недостатком данного метода распределения памяти является фрагментация на уровне сегментов и более медленное по сравнению со страничной организацией преобразование адреса.
Существует также гибридная странично-сегментная организация виртуальной памяти

Socket — название программного интерфейса для обеспечения обмена данными между процессами, он же, специальный файл, используемый для межпроцессного взаимодействия, который обеспечивает связь между двумя процессами. Помимо отправки данных, процессы могут отправлять файловые дескрипторы через соединение сокета домена Unix с помощью системных вызовов sendmsg () и recvmsg (). Процессы могут исполняться как на одной ЭВМ, так и на различных ЭВМ, связанных между собой сетью. Сокет — абстрактный объект, представляющий конечную точку соединения в канале двусторонней связи. Подпрограммы сокета создают канал связи, и этот канал используется для передачи данных между прикладными программами локально или по сети. Каждый сокет в сети имеет уникальное имя, связанное с ним, называемое дескриптором сокета - целое число, обозначающее сокет и позволяющее прикладным программам обращаться к нему при необходимости. Используя электрическую аналогию, 
вы можете представить канал связи как электрический провод с вилкой и представить порт или розетку как электрическую розетку или розетку. Когда клиент запускает вызов сокета, соединение сокета устанавливается между приложением на клиенте и приложением на сервере. Другая аналогия, используемая для описания связи через розетку, - это телефонный разговор. Набор номера с телефона аналогичен вызову через розетку. Блок телефонной коммутации знает, где логически сделать правильный переключатель для завершения вызова в удаленном месте. Во время телефонного разговора это соединение присутствует и происходит обмен информацией. После того, как вы положите трубку, соединение будет разорвано, и вы должны будете запустить его снова. Клиент использует вызов функции socket () для запуска механизма логического переключения для подключения к серверу. Как и в случае с доступом к файлам, пользовательские процессы просят операционную систему создать сокет, когда он необходим. 
Система возвращает целое число, дескриптор сокета (sd), который приложение использует каждый раз, когда оно хочет обратиться к этому сокету. Основное различие между сокетами и файлами заключается в том, что операционная система связывает файловые дескрипторы с файлом или устройством, когда вызов open () создает файлвый дескриптор. С сокетами прикладные программы могут либо указать адрес назначения каждый раз, когда они используют сокет, например, при отправке дейтаграмм, либо привязать адрес назначения к сокету. В некоторых отношениях сокеты ведут себя как файлы или устройства UNIX, поэтому их можно использовать с такими традиционными операциями, как read () или write (). Например, после того, как две прикладные программы создают сокеты и открывают соединение между ними, одна программа может использовать write () для отправки потока данных, а другая может использовать read () для его получения. Поскольку каждый файл или сокет имеет уникальный дескриптор, система точно знает, куда отправлять и получать данные
В отличие от именованных каналов, которые допускают только однонаправленный поток данных, сокеты полностью поддерживают дуплекс. Можно ждать сокета, используя следующие функции асинхронного ввода-вывода: aio_read () - Асинхронное чтение из сокета, aio_write () - Асинхронная запись в сокет, aio_cancel () - Отменить запрос асинхронного ввода-вывода, aio_suspend () - Ожидание запроса асинхронного ввода-вывода, aio_error () - Получить статус ошибки для операции асинхронного ввода-вывода, aio_return () - Получить статус возврата для операции асинхронного ввода-вывода
Сокет домена Unix (англ. Unix domain socket, UDS) или IPC-сокет (сокет межпроцессного взаимодействия) — конечная точка обмена данными, подобная Интернет-сокету, но не использующая сетевой протокол для взаимодействия (обмена данными). Используется в операционных системах, поддерживающих стандарт POSIX, для межпроцессного взаимодействия. Доменные соединения Unix являются по сути байтовыми потоками, сильно напоминая сетевые соединения, но при этом все данные остаются внутри одного компьютера (то есть обмен данными происходит локально). UDS используют файловую систему как адресное пространство имен, то есть они представляются процессами как иноды в файловой системе. Это позволяет двум различным процессам открывать один и тот же сокет для взаимодействия между собой. Однако, конкретное взаимодействие, обмен данными, не использует файловую систему, а только буферы памяти ядра. Фактически - это двунаправленный канал, похожий на сокет TCP / IP. Сервер прослушивает и принимает соединения от клиентов, 
а затем может связываться с клиентом по вновь принятому соединению. Что особенного в доменных сокетах unix, так это то, что вместо IP-адреса и номера порта в качестве адреса используется имя файла. Это позволяет другим приложениям, которые ничего не знают о работе сети, получать информацию об открытии файла и чтении или записи, а данные отправляются на сервер, а не на диск.

Logical Volume Manager (LVM) - это очень мощная система управления томами с данными для Linux. Она позволяет создавать поверх физических разделов (или даже неразбитых винчестеров) логические тома, которые в самой системе будут видны как обычные блочные устройства с данными (т.е. как обычные разделы). Основные преимущества LVM в том, что во-первых одну группу логических томов можно создавать поверх любого количества физических разделов, а во-вторых размер логических томов можно легко менять прямо во время работы. Кроме того, LVM поддерживает механизм снапшотов, копирование разделов «на лету» и зеркалирование, подобное RAID-1.